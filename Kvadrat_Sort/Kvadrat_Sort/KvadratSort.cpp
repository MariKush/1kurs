// KvadratSort.cpp: 
//
/*
Сортировка методом квадратичной выборки. 
Массив, состоящий из М элементов, разбивают на SQRT(M) групп по SQRT(M) элементов в каждой. 
В результате сплошного просмотра в каждой группе находят и заносят в рабочие переменные элементы с наименьшими значениями. 
Затем просматривают переменные и переменную с наименьшим значением заносят в выходной массив. 
После этого осуществляют поиск наименьшего элемента в той группе, 
из переменной которой элемент был перенесен в выходной массив. 
Процесс повторяют. При каждом занесении элемента в переменную ее стирают в основном массиве.
//
Идея алгоритма. 
Массив А из N элементов, разделяется на "корень из N" групп, по "корень из N" элементов в каждой группе. 
Находится наименьший элемент в каждой группе и помещается в некоторый вспомогательный массив В. 
Далее во вспомогательном массиве находится минимальный элемент. 
Данный элемент заносится на следующую позицию выходного массива С, 
и в массиве В заменяется на следующий по величине элемент из этой группы массива А, из которой он поступил.
Снова находится наименьший элемент во вспомогательном массиве. 
Этот элемент - второй по величине в исходном массиве. 
Процесс повторяется до тех пор, пока ис ходных массив не будет отсортирован.
В данном методе используются 3 массива, А - исходный, В - вспомогательный, С - выходной.
*/
//

#include "stdafx.h"
#include <iostream>
using namespace std;

typedef struct Node 
{
	int dat;
	Node *next;
} Listn, *Listp;

//---------------------------------------------------
//додати елемент в кінець списку
void add(Listp &Root, int Value)
{
	Listp p = new Node;
	p->dat = Value;
	p->next = NULL;
	if (Root)
	{
		Listp t = Root;
		while (t->next)
			t = t->next;
		t->next = p;
	}
	else
	{
		Root = p;
	}
}


//--------------------------------------------------------
//пошук мінімального елемента
Listp find_min(Listp const pbeg)
{
	Listp pm = pbeg;
	Listp pv = pbeg;
	while (pv) 
	{
		if (pv->dat < pm->dat)
			pm = pv;
		pv = pv->next;
	}
	return pm;
}

//--------------------------------------------------------
//видалення елемента зі списку
void del(Listp &first, Listp del)
{
	Listp t = first;
	Listp buf;
	if (first && first != del) // Якщо список існує, і ключовий елемент не перший
	{ 
		while (t && t->next != del) t = t->next; // Знаходимо попередній елемент
		if (t) // Якщо він існує, то видаляємо
		{ 
			buf = t->next;
			t->next = t->next->next;
			delete buf;
		}
		else
			cout << "ERROR" << endl;
	}
	else 
		if (first == del) // Якщо перший
		{ 
			buf = del;
			first = del->next;
			delete buf;
		}
		else 
			cout << "empty list" << endl;
}

//-------------------------------------------------------
//виведення списку
void lprint(Listp p)
{
	while (p)
	{
		cout << p->dat << ' ';
		p = p->next;
	}
	cout << endl;
}

//-------------------------------------------------------
//знищення списку
void ldel(Listp p) {
	Listp t;
	while (p) {
		t = p;
		p = p->next;
		delete t;
	}
}

//-------------------------
int main()
{
	int n;
	//визначаємось з кількістю елементів
	cout << "Number = ";
	cin >> n;
	cout << endl;
	
	Listp a = new Node();
	a->dat = rand() % 1000;
	a->next = NULL;

	for (int i = 1; i < n; i++) //додавання елементів в кінець списку 
	{
		add(a, rand() % 1000);
	}



	Listp b = NULL;

	for (int i = 0; i < n; i++) 
	{

		cout << "a: "; lprint(a); cout << "___________________________________________________________" << endl << endl;

		add(b, find_min(a)->dat);

		cout << "b: "; lprint(b); cout << endl;

		del(a, find_min(a));

	}

	int s = sqrt(n)+1;
	cout << "sqrt = " << s << endl;

	Listp *p = 0, *q = 0;
	p = new Listp [s];
	q = p;
	
	for (int i = 0; (i < s) && (a); i++)
	{
		for (int j = 0; (j < s) && (a); j++)
		{
			a = a->next;
		}
		*q++;
	}

	cout << "array ap: ";
	//виведення даних 
	for (int i = 0; (i < s) && (a); i++)
	{
		for (int j = 0; (j < s) && (a); j++)
		{
			a = a->next;
		}
		*q++;
	}

	delete[] p;  p = 0;

	ldel(a);  //знищення списку
	ldel(b);
	system("pause");
	return 0;
}
